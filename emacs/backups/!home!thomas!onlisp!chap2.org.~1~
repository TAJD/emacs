#+title: Notes from Chapter 2 
#+author: Tom

In Lisp Functions can be data. This means that they can be passed as arguments to other functions.

These expressions all have the same effect:

#+begin_src lisp
(+ 1 2)
(apply #'+ '(1 2))
(apply (symbol-function '+) '(1 2))
(apply #'(lambda (x y) (+ x y)) '(1 2))
#+end_src

#+RESULTS:
: 3

Many functions in lisp take functions as arguments - ~mapcar~ for example.

#+begin_src lisp
(mapcar #'(lambda (x) (+ x 10))
   '(1 2 3))
#+end_src

#+RESULTS:
| 11 | 12 | 13 |

#+begin_src lisp
(mapcar #'+
   '(1 2 3)
   '(10 100 1000))
#+end_src

#+RESULTS:
| 11 | 102 | 1003 |

Lisp has two useful functions ~sort~ and ~remove-if~. To remember how ~sort~ works remember that if you sort a list with no duplicates by < and then apply < to the resulting list it will return true.

#+begin_src lisp
(sort '(1 4 2 5 6 7 3) #'<)
#+end_src

#+RESULTS:
| 1 | 2 | 3 | 4 | 5 | 6 | 7 |

Remove if takes a list and removes all the elements for which a function returns true.

#+begin_src lisp
(remove-if #'evenp '(1 2 3 4 5 6 7))
#+end_src

#+RESULTS:
| 1 | 3 | 5 | 7 |

Closures - when we define a function containing free variables, the system must contain copies of those variables saved at run time. These are called closures.

Here's an example. Suppose we want to create a function that takes a list of numbers and adds a certain amount to each one.

The function passed to mapcar within ~list+~ is actually a closure - as ~n~ is free.

#+begin_src lisp
(defun list+ (lst n)
   (mapcar #'(lambda (x) (+ x n))
      lst))

(list+ '(1 2 3) 10)
#+end_src

#+RESULTS:
| 11 | 12 | 13 |

Closures can also be used as functions with local state. These functions share a variable which serves as a counter.

#+begin_src lisp
(let ((counter 0))
   (defun new-id ()
      (incf counter))
   (defun reset-id () (setq counter 0)))
#+end_src

#+RESULTS:
: RESET-ID

It's also possible to return functions with local state. This function ~make-adder~ returns a function that when called adds a number to its argument.

#+begin_src lisp
(defun make-adder (n)
   #'(lambda (x) (+ x n)))
#+end_src

#+RESULTS:
: MAKE-ADDER

#+begin_src lisp
(setq add2 (make-adder 2)
      add10 (make-adder 10))
#+end_src

#+RESULTS:
: #<CLOSURE (LAMBDA (X) :IN MAKE-ADDER) {1002B2BC1B}>

#+begin_src lisp
(funcall add2 5)
#+end_src

#+RESULTS:
: 7

#+begin_src lisp
(funcall add10 3)
#+end_src

#+RESULTS:
: 13

You can return a group of closures which share the same data objects. The snippet below shows a function that contains three databases. It takes an assoc list (our database standin) and returns a list of closures that query, add and delete entries.

#+begin_src lisp
(defun make-dbms (db)
   (list
      #'(lambda (key)
         (cdr (assoc key db)))
      #'(lambda (key val)
         (push (cons key val) db)
                            key)
      #'(lambda (key)
         (setf db (delete key db :key #'car))
                 key)))
#+end_src

#+RESULTS:
: MAKE-DBMS

#+begin_src lisp
(setq cities (make-dbms '((boston . us) (paris . france))))
#+end_src

#+RESULTS:
: (#<CLOSURE (LAMBDA (KEY) :IN MAKE-DBMS) {1002E5E2BB}>
:  #<CLOSURE (LAMBDA (KEY VAL) :IN MAKE-DBMS) {1002E5E2DB}>
:  #<CLOSURE (LAMBDA (KEY) :IN MAKE-DBMS) {1002E5E2FB}>)

#+begin_src lisp
(funcall (car cities) 'boston)
#+end_src

#+RESULTS:
: US

Labels can be used to help when functions need to use bindings in their local environment (like lambdas) and need to be referred to themselves (not like lambdas).

#+begin_src lisp

#+end_src







