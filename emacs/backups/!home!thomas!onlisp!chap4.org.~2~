#+title: Notes from Chapter 4 of On Lisp 
#+author: Tom

* Utility functions

Operators in Lisp come in two forms - macros and functions.

Lisp embodies the philosophy of "bottom up programming" - i.e. start from the ground and work towards the solution.

As part of writing the solution we need to add new operators (utility functions) that make the program easy to write.

Bottom up programming means simulateneously writing the program and the programming language.

When writing utility functions remember to define the general and pass the specific in as an argument.

** Invest in abstraction

Brevity is the soul of wit.

** Operations on lists

Here are some utility functions that usually require defining once.

#+begin_src lisp
(proclaim '(inline last1 single append1 conc1 mklist)) ;; being inlined for efficiency

;; returns the last element in a list
(defun last1 (lst) (car (last lst)))

;; tests if there is a single element in the list
(defun single (lst) (and (consp lst) (not (cdr lst))))

;; non destructively attach an element to the end of the list
(defun append1 (lst obj) (append lst (list obj)))

;; destructively attach an element to the end of the list
(defun conc1 (lst obj) (nconc lst (list obj)))

;; ensure that something is a list
(defun mklist (obj) (if (listp obj) obj (list obj)))
#+end_src

#+RESULTS:
: MKLIST

#+begin_src lisp
;; a more efficient way of comparing the length of two lists
(defun longer (x y) 
   (labels ((compare (x y) 
                     (and (consp x) 
                          (or (null y) (compare (cdr x) (cdr y)))))) 
	   (if (and (listp x) (listp y)) 
               (compare x y) 
	       (> (length x) (length y)))))

;; applies a function to a list
(defun filter (fn lst) 
    (let ((acc nil)) 
         (dolist (x lst) 
                 (let ((val (funcall fn x))) 
                      (if val (push val acc)))) (nreverse acc)))

;; for grouping lists into sublists of length n with the remainder put into a sublist  
(defun group (source n) 
    (if (zerop n) (error "zero length")) 
    (labels ((rec (source acc) 
             (let ((rest (nthcdr n source))) 
              (if (consp rest) 
                  (rec rest (cons (subseq source 0 n) acc)) 
                  (nreverse (cons source acc)))))) 
               (if source (rec source nil) nil)))
#+end_src

#+RESULTS:
: GROUP

Filter recieves a function and an argument and returns a list of whatever non nil values are returned by the function as applied to the list.

Note that filter uses an accumulator to hold the non nil values.

#+begin_src lisp
(filter #'(lambda (x) (if (numberp x) (1+ x)))
   '(a 1 2 b 3 c d 4))
#+end_src

#+RESULTS:
| 2 | 3 | 4 | 5 |

An example of using group to group lists:

#+begin_src lisp
(group '(a b c d e f g) 2)
#+end_src

#+RESULTS:
| A | B |
| C | D |
| E | F |
| G |   |










